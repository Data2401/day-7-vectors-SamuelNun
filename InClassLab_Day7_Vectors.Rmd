---
title: "In Class Lab"
author: "Samuel Nunez"
date: "DATA 2401"
output: html_document
---
**Note: Your exam will be in a similar format to this (RMarkdown File with Questions and Code chunks for your answers), so make sure you have the process for knitting to html working.** 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## In-Class Exercises

### Set 1 

1. Use the colon operator : to create a vector `n` of numbers from 10:49
2. Use the `length()` function to get the number of elements in `n`
3. Add 1 to each element in `n` and print the result
4. Create a vector `m` that contains the numbers 10 to 1 (in that order), in two different ways, neither of which is just typing "10, 9 , 8 ...".  Hint: use one of the helper functions we learned.
5. Subtract `m` FROM `n`. Note the recycling!

```{r}
n <- 10:49 # Creates vector n with numbers 10 to 49
length(n) # Shows the length of the vector
n + 1 # Adds 1 to each element in n

m <- 10:1        # Creating a vector using the colon (:) operator
m <- seq(10 , 1) # Creating a vector using seq()

n - m # Subtracts vector m from n

```
### Set 2 

1. Use the `seq()` function to produce a range of numbers from -5 to 10 in `0.1` increments. Store it in a variable `x_range`
2. Create a vector `sin_wave` by calling the `sin()` function on each element in `x_range`.
3. Use the `plot()` function to plot your "wave"!
     + the x vector goes in the first argument, the y vector goes in the second argument
     + You'll need to add the argument `type = "l"` for a line. NOTE: That is a lower case "L", not a 1. 

``` {r}
x_range <- seq(-5, 10, by = .1) # Creates a vector, x_range, with numbers -5 to 10 in increments of .1
sin_wave <- sin(sin(x_range))   # Creates a vector, sin_wave, that runs the sin() function on each x_range and stores it

plot(x_range, sin_wave, type = "l") # Displays a plot of sin_wave vs x_range
```

### Set 3 

1. Use `:` to make a vector of the integers from 40 to 50 called `first_nums`
2. Use `seq()` to make a vector of the integers from 51 to 60 called `next_nums`
3. Combine them using `c()`
4. Use indexing to access the 7th number in your combined vector
5. Use indexing to access the 5th to the 8th numbers in your combined vector
6. Use indexing to create a new vector that contains the first 3 elements and last 3 elements of your combined vector. 
7. Bonus/extra: do the above in a way that would work no matter how long the vector is (as long as it's longer than 2 elements)

``` {r}
first_nums <- 40:50 # Creates a vector, first_nums, that contains the numbers 40 through 50
next_nums <- seq(51, 60) # Creates a vector, next_nums, that contains the numbers 51 through 60

combined_nums <- c(first_nums, next_nums) # Combines both vectors into one called combined_nums

combined_nums[7] # Indexes the 7th element in combined_nums
combined_nums[5:8] # Indexes the 5th to the 8th elements in combined_nums

first_three <- combined_nums[1:3] # Creates a vector that gets the first three elements of combined_nums
last_three <- combined_nums[seq(length(combined_nums)- 2 , length(combined_nums))] # Creates a vector that gets the last three elements of combined_nums

new_nums <- c(first_three, last_three)# Combines both vectors into new_nums
new_nums # Outputs the vector with the first three and last three elements

```

## In-Class Activities

1. Missingness 

* Use is.na(x) to find which entries are missing in the vector below.
* Create x_no_na that removes the missing values.
* Replace the missing values with the mean of the non-missing values (compute the mean yourself from x_no_na).
     * Hint: x[is.na(x)] <- ...

```{r}
x <- c(3.2, NA, 4.1, 5.0, NA, 2.8) # Vector with pre-set values
is.na(x) # Displays if each element is True or False
x_no_na <- x[!is.na(x)] # Removes all the NA from the list

x_mean <- sum(x_no_na)/length(x_no_na) # Gets the mean of the non-NA values
x_replaced_na <- x # Creates a new vector to replace NA values with mean
x_replaced_na[is.na(x)] <- x_mean # Replaces NA values with mean
x_replaced_na # Displays new vector
```

1. Logical indexing

* Using the `grades` vector from class:
* Create a logical vector is_a <- grades >= 90
* Print the values that are A’s (you already do this)
* Now print the indices/positions of the A’s using which(is_a)
* How many A’s are there? Do it two ways:
     * length(grades[is_a])
     * sum(is_a) (since TRUE counts as 1)

```{r}
grades <- c(99,  77, 100,  91,  87,  72,  82,  94,  81) # Grades vector from class
is_a <- grades >= 90 # Boolean list of grades that are A's

grades[is_a] # Displays all A's
which(is_a) # Displays the index of the A's
length(grades[is_a]) # Outputs the number of A's
sum(is_a) # Outputs the number of A's

```

1.  Emperical probabilities

* Set a seed: `set.seed(2401)`
* Simulate 200 die rolls (fair die) in a vector rolls (use sample(1:6, ...))
* Use table(rolls) to count how many of each face occurred.
* Convert counts to proportions (estimated probabilities) by dividing by length(rolls).
* Which face was most common in your simulation?


```{r}
set.seed(2401) # Sets seed for randomization

rolls <- sample(1:6, size = 200, replace = TRUE) # Simulates 200 rols of a 6-sided dice
counts <- table(rolls) # Counts how many times each face appears
counts # Outputs counts

props <- counts/length(rolls) # Converts counts to proportions
props # Outputs the proportions

```


1. Write a *function* to simulate rolling a 6-sided die and returns the result.

```{r}
roll_die <- function() { # Function simulates rolling a 6-sided die
  return(sample(1:6,size = 1)) # Outputs a random die roll
}
roll_die() # Runs function
```



1. Write a function to simulate rolling 2 6-sided dice that returns the sum of the rolls. 

```{r}
roll_two_die <- function() { # Function simulates rolling two 6-sided die
  return( sum(sample(1:6, size = 2, replace = TRUE)) ) # Outputs the two random die rolls
}
roll_two_die() # Runs function

```


1. Write a function that takes two people name's as strings, simulates rolling a 6-sided die for each of the names, then returns the name of the person with the higher roll. The function should reroll once on a tie, but if there is a second tie, it should return "draw". 


```{r}
# Your one-roll function goes here

name_roll <- function(name1, name2) { # Function takes two names and simulates one die roll each and outputs the winner

roll_1 <- roll_die() # Rolls once for player 1
roll_2 <- roll_die() # Rolls once for player 2

# Outputs winner from both rolls
if (roll_1 > roll_2) 
  return(name1)
if (roll_2 > roll_1) 
  return(name2)
  
# Rolls dice again if results are tie
roll_1 <- roll_die()
roll_2 <- roll_die()
  
# Outputs winner from both rolls
if (roll_1 > roll_2) return(name1)
if (roll_2 > roll_1) return(name2)

return("draw") # Outputs draw message if tie happens a second time
}

name_roll("Sam", "John")

```


1. Write a second function (you may start by modifying the first one) that takes two names as strings, simulates both of them rolling die 15 times, and returns the name of the person who "won" more rolls. Don't reroll ties this time, but don't count them as "wins". 

Process: 

* Simulate 15 rolls each for two players, p1 and p2 (vectors).
* Create a logical vector p1_wins <- p1 > p2
* Create a logical vector p2_wins <- p2 > p1
* Create a logical vector ties <- p1 == p2
* Report:
     * number of p1 wins (sum(p1_wins))
     * number of p2 wins (sum(p2_wins))
     * number of ties (sum(ties))

```{r}
name_roll_15 <- function(name1, name2) { # Function takes two names and simulates one die roll each and outputs the winner

p1 <- sample(1:6, size = 15, replace = TRUE) # Rolls once for player 1
p2 <- sample(1:6, size = 15, replace = TRUE) # Rolls once for player 2

# Vector logic for wins and ties
p1_wins <- p1 > p2 
p2_wins <- p2 > p1 
ties <- p1 == p2 

print(paste(name1, "wins:", sum(p1_wins))) # Displays how many times p1 wins
print(paste(name2, "wins:", sum(p2_wins)))# Displays how many times p2 wins
print(paste("Ties:", sum(ties))) # Displays how many player tied

# Outputs winner
if (sum(p1_wins) > sum(p2_wins)) 
  return(name1)
else if (sum(p2_wins) > sum(p1_wins)) 
  return(name2)
else
  return("draw") # Outputs draw message if neither player has more wins than the other
}

name_roll_15("Sam", "John")
```


3. Modify your function from (2) so that the person in the first argument has a die that is weighted to get higher numbers more often (you may decide the actual percentage change). Run the function ten or so times. Does the second person ever win?

```{r}
# Your "cheating" function goes here
name_roll_15_cheating <- function(name1, name2) { # Function takes two names and simulates one die roll each and outputs the winner

weighted_die <- c(0.05, 0.05, 0.05, 0.25, 0.30, 0.30) # Changes the probability to roll high

p1 <- sample(1:6, size = 15, replace = TRUE, prob = weighted_die) # Rolls once for player 1
p2 <- sample(1:6, size = 15, replace = TRUE) # Rolls once for player 2

# Vector logic for wins and ties
p1_wins <- p1 > p2 
p2_wins <- p2 > p1 
ties <- p1 == p2 

print(paste(name1, "wins:", sum(p1_wins))) # Displays how many times p1 wins
print(paste(name2, "wins:", sum(p2_wins)))# Displays how many times p2 wins
print(paste("Ties:", sum(ties))) # Displays how many player tied

# Outputs winner
if (sum(p1_wins) > sum(p2_wins)) 
  return(name1)
else if (sum(p2_wins) > sum(p1_wins)) 
  return(name2)
else
  return("draw") # Outputs draw message if neither player has more wins than the other
}

name_roll_15("Sam", "John")
```

I might just be unlcuky, but I've seen player 2 win more times than player 1 has, even after drastically changing the weighted die.
